using Newtonsoft.Json;
using System.Globalization;

// unit generated by AI

namespace SkyCat
{
  public class HexStringToNullableByteConverter : JsonConverter<byte?>
  {
    public override byte? ReadJson(JsonReader reader, Type objectType, byte? existingValue, bool hasExistingValue, JsonSerializer serializer)
    {
      if (reader.TokenType == JsonToken.Null)
        return null;

      string hexString = reader.Value?.ToString();

      if (string.IsNullOrWhiteSpace(hexString))
        return null;

      // Strip 0x prefix if present
      if (hexString.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
        hexString = hexString[2..];

      if (byte.TryParse(hexString, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out byte result))
        return result;

      throw new JsonException($"Invalid hex byte value: {hexString}");
    }

    public override void WriteJson(JsonWriter writer, byte? value, JsonSerializer serializer)
    {
      if (value is null)
        writer.WriteNull();
      else
        writer.WriteValue($"0x{value:X2}");
    }
  }

  public class HexStringToNullableByteArrayConverter : JsonConverter<byte?[]>
  {
    private static readonly HexStringToNullableByteConverter ElementConverter = new();

    public override byte?[] ReadJson(JsonReader reader, Type objectType, byte?[] existingValue, bool hasExistingValue, JsonSerializer serializer)
    {
      if (reader.TokenType == JsonToken.Null)
        return null;

      if (reader.TokenType == JsonToken.StartArray)
      {
        var list = new List<byte?>();
        while (reader.Read())
        {
          if (reader.TokenType == JsonToken.EndArray)
            break;

          // Use ElementConverter directly to parse each array element
          byte? value = ElementConverter.ReadJson(reader, typeof(byte?), null, false, serializer);
          list.Add(value);
        }

        return list.ToArray();
      }
      else if (reader.TokenType == JsonToken.String)
      {
        // Handle a case where we get a single string with multiple bytes like "FEFF" or "0xFEFF"
        string hexString = reader.Value?.ToString();
        if (string.IsNullOrWhiteSpace(hexString))
          return Array.Empty<byte?>();

        if (hexString.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
          hexString = hexString[2..];

        // Parse every two characters as a byte
        var bytes = new List<byte?>();
        for (int i = 0; i < hexString.Length; i += 2)
        {
          if (i + 1 >= hexString.Length) 
          {
            // Handle odd-length string by padding with 0
            string byteString = hexString.Substring(i, 1) + "0";
            bytes.Add(byte.Parse(byteString, NumberStyles.HexNumber, CultureInfo.InvariantCulture));
          }
          else
          {
            string byteString = hexString.Substring(i, 2);
            bytes.Add(byte.Parse(byteString, NumberStyles.HexNumber, CultureInfo.InvariantCulture));
          }
        }
        return bytes.ToArray();
      }

      throw new JsonException($"Unexpected token {reader.TokenType} when deserializing byte?[].");
    }

    public override void WriteJson(JsonWriter writer, byte?[] value, JsonSerializer serializer)
    {
      if (value == null)
      {
        writer.WriteNull();
        return;
      }

      writer.WriteStartArray();
      foreach (var b in value)
      {
        ElementConverter.WriteJson(writer, b, serializer);
      }
      writer.WriteEndArray();
    }
  }

  // Additional converters from your solution
  public class HexStringToByteConverter : JsonConverter<byte>
  {
    public override byte ReadJson(JsonReader reader, Type objectType, byte existingValue, bool hasExistingValue, JsonSerializer serializer)
    {
      string hexString = reader.Value?.ToString();

      if (string.IsNullOrWhiteSpace(hexString))
        throw new JsonException("Hex string cannot be null or empty.");

      if (hexString.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
        hexString = hexString[2..];

      if (byte.TryParse(hexString, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out byte result))
        return result;

      throw new JsonException($"Invalid hex byte value: {hexString}");
    }

    public override void WriteJson(JsonWriter writer, byte value, JsonSerializer serializer)
    {
      writer.WriteValue($"0x{value:X2}");
    }
  }

  public class HexStringToByteArrayConverter : JsonConverter<byte[]>
  {
    private static readonly HexStringToByteConverter ElementConverter = new();

    public override byte[] ReadJson(JsonReader reader, Type objectType, byte[] existingValue, bool hasExistingValue, JsonSerializer serializer)
    {
      if (reader.TokenType == JsonToken.Null)
        return null;

      if (reader.TokenType == JsonToken.StartArray)
      {
        var list = new List<byte>();
        while (reader.Read())
        {
          if (reader.TokenType == JsonToken.EndArray)
            break;

          byte value = ElementConverter.ReadJson(reader, typeof(byte), 0, false, serializer);
          list.Add(value);
        }
        return list.ToArray();
      }
      else if (reader.TokenType == JsonToken.String)
      {
        string hexString = reader.Value?.ToString();
        if (string.IsNullOrWhiteSpace(hexString))
          return Array.Empty<byte>();

        if (hexString.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
          hexString = hexString[2..];

        // Parse every two characters as a byte
        var bytes = new List<byte>();
        for (int i = 0; i < hexString.Length; i += 2)
        {
          if (i + 1 >= hexString.Length)
          {
            // Handle odd-length string by padding with 0
            string byteString = hexString.Substring(i, 1) + "0";
            bytes.Add(byte.Parse(byteString, NumberStyles.HexNumber, CultureInfo.InvariantCulture));
          }
          else
          {
            string byteString = hexString.Substring(i, 2);
            bytes.Add(byte.Parse(byteString, NumberStyles.HexNumber, CultureInfo.InvariantCulture));
          }
        }
        return bytes.ToArray();
      }

      throw new JsonException($"Unexpected token {reader.TokenType} when deserializing byte[].");
    }

    public override void WriteJson(JsonWriter writer, byte[] value, JsonSerializer serializer)
    {
      if (value == null)
      {
        writer.WriteNull();
        return;
      }

      writer.WriteStartArray();
      foreach (var b in value)
      {
        ElementConverter.WriteJson(writer, b, serializer);
      }
      writer.WriteEndArray();
    }
  }

  public class DictionaryStringToByteArrayConverter : JsonConverter<Dictionary<string, byte[]>>
  {
    private static readonly HexStringToByteArrayConverter ArrayConverter = new();

    public override Dictionary<string, byte[]> ReadJson(JsonReader reader, Type objectType, Dictionary<string, byte[]> existingValue, bool hasExistingValue, JsonSerializer serializer)
    {
      if (reader.TokenType != JsonToken.StartObject)
        throw new JsonException();

      var dict = new Dictionary<string, byte[]>();
      while (reader.Read())
      {
        if (reader.TokenType == JsonToken.EndObject)
          break;

        string key = (string)reader.Value;
        reader.Read();
        var array = ArrayConverter.ReadJson(reader, typeof(byte[]), null, false, serializer);
        dict[key] = array;
      }

      return dict;
    }

    public override void WriteJson(JsonWriter writer, Dictionary<string, byte[]> value, JsonSerializer serializer)
    {
      writer.WriteStartObject();
      foreach (var kvp in value)
      {
        writer.WritePropertyName(kvp.Key);
        ArrayConverter.WriteJson(writer, kvp.Value, serializer);
      }
      writer.WriteEndObject();
    }
  }

  public class DictionaryEnumToObjectConverter<TDictionary, TEnum, TObject> : JsonConverter<TDictionary>
      where TEnum : struct, Enum
      where TObject : class
      where TDictionary : Dictionary<TEnum, TObject>, new()
  {
    public override TDictionary ReadJson(JsonReader reader, Type objectType, TDictionary existingValue, bool hasExistingValue, JsonSerializer serializer)
    {
      if (reader.TokenType != JsonToken.StartObject)
        throw new JsonException("Expected StartObject");

      var result = new TDictionary();

      while (reader.Read())
      {
        if (reader.TokenType == JsonToken.EndObject)
          return result;

        if (reader.TokenType != JsonToken.PropertyName)
          throw new JsonException("Expected property name (enum key)");

        string keyString = (string)reader.Value;

        if (!Enum.TryParse(keyString, ignoreCase: true, out TEnum enumKey))
          throw new JsonException($"Invalid enum key: {keyString}");

        reader.Read(); // move to object
        TObject value = serializer.Deserialize<TObject>(reader);
        result[enumKey] = value;
      }

      throw new JsonException("Unexpected end of JSON");
    }

    public override void WriteJson(JsonWriter writer, TDictionary value, JsonSerializer serializer)
    {
      writer.WriteStartObject();

      foreach (var kvp in value)
      {
        writer.WritePropertyName(kvp.Key.ToString());
        serializer.Serialize(writer, kvp.Value);
      }

      writer.WriteEndObject();
    }
  }
}